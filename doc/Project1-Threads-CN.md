# Project 1: Threads

#### OUR-BEST-OS

在这个任务中，我们给你一个最小功能的线程系统。你的工作是扩展这个系统的功能，以便更好地理解同步问题。

在这个任务中，你将主要在线程目录下工作，同时在设备目录下进行一些工作。编译工作应该在线程目录下进行。

在你阅读这个项目的描述之前，你应该阅读以下所有的部分。1. 引言，C.编码标准，E.调试工具，F.开发工具。你至少应该浏览从A.1 Loading到A.5 Memory Allocation的材料，特别是A.3 Synchronization。为了完成这个项目，你还需要阅读 B. 4.4BSD Scheduler。

## 2.1 背景

### 2.1.1 理解线程

第一步是阅读和理解初始线程系统的代码。Pintos已经实现了线程创建和线程完成，一个在线程之间切换的简单调度器，以及同步基元（semaphores、锁、条件变量和优化障碍）。

其中一些代码可能看起来略显神秘。如果你还没有编译和运行基础系统，如介绍中所述（见第1.介绍），你现在就应该这样做。你可以通过阅读部分源代码来了解发生了什么。如果你愿意，你可以在几乎任何地方添加对printf()的调用，然后重新编译并运行，看看会发生什么，以及以什么顺序进行。你也可以在调试器中运行内核，在有趣的地方设置断点，单步通过代码和检查数据，等等。

当一个线程被创建时，你是在创建一个新的上下文来进行调度。你提供一个要在这个上下文中运行的函数作为 thread_create() 的参数。线程第一次被调度和运行时，它从该函数的开头开始，并在该上下文中执行。当函数返回时，线程终止。因此，每个线程就像一个运行在Pintos内部的迷你程序，传递给thread_create()的函数就像main()一样。

在任何时候，只有一个线程在运行，其余的线程（如果有的话）都会成为非活动线程。调度器决定下一个要运行的线程。(如果在任何给定的时间没有线程准备好运行，那么在idle()中实现的特殊 "空闲 "线程就会运行。) 当一个线程需要等待另一个线程做某事时，同步基元可以强制进行上下文切换。

上下文切换的机制在 threads/switch.S 中，这是 80x86 的汇编代码。(你不必理解它。)它保存了当前运行的线程的状态，并恢复了我们要切换到的线程的状态。

使用GDB调试器，慢慢跟踪上下文切换，看看会发生什么（见E.5节GDB）。你可以在schedule()上设置一个断点开始，然后从那里单步走。 (2)一定要跟踪每个线程的地址和状态，以及每个线程的调用栈上有什么程序。你会注意到，当一个线程调用switch_threads()时，另一个线程开始运行，新线程做的第一件事就是从switch_threads()返回。当你理解了为什么被调用的switch_threads()和返回的switch_threads()不一样，你就会理解线程系统。更多信息请参见A.2.3线程切换一节。

警告。在Pintos中，每个线程都被分配了一个小的、固定大小的执行堆栈，大小刚好在4 kB以下。内核试图检测堆栈溢出，但它无法做到完美。如果你把大的数据结构声明为非静态的局部变量，比如int buf[1000];，你可能会引起奇怪的问题，比如神秘的内核恐慌。栈分配的替代方法包括页分配器和块分配器（参见A.5节内存分配）。

### 2.1.2 源文件

这里是线程目录下的文件的简要概述。你不需要修改这些代码的大部分，但希望通过介绍这个概述能让你对要看的代码有一个开始。

"loader.S"
"loader.h"
内核加载器。组装成512字节的代码和数据，由PC BIOS加载到内存中，进而在磁盘上找到内核，将其加载到内存中，并跳转到start.S中的start()，详见A.1.1 The Loader一节。你应该不需要看这段代码或修改它。
"start.S"
在80x86 CPU上进行内存保护和32位操作所需的基本设置。与加载器不同，这段代码实际上是内核的一部分。详情请参见A.1.2 低级内核初始化一节。
"kernel.lds.S"
用于链接内核的链接器脚本。设置内核的加载地址，并将start.S安排在内核映像的开头附近。详情请参见A.1.1 The Loader一节。同样，你应该不需要看这段代码或者修改它，但是这里有一段代码，以防你好奇。
init.c
init.h
内核初始化，包括main()，内核的 "主程序"。你至少应该看一下main()，看看有什么被初始化了。你可能想在这里添加你自己的初始化代码。详情请参见A.1.3 高层内核初始化一节。
thread.c
thread.h
基本的线程支持。thread.h定义了线程结构，你可能会在这四个项目中修改它。更多信息请参见 A.2.1 struct thread 和 A.2 Threads。
switch.S
switch.S
用于切换线程的汇编语言例程。上面已经讨论过了。更多信息请参见A.2.2线程函数一节。
palloc.c
palloc.h
页分配器，它以4 kB页的倍数分配系统内存。更多信息请参见A.5.1节Page Allocator。
详见A.5.1节页面分配器。
malloc.h
一个简单的内核malloc()和free()的实现。更多信息请参见章节 A.5.2 Block Allocator。
interrupt.c
interrupt.h
基本的中断处理以及开启和关闭中断的函数。更多信息请参见章节 A.4 中断处理。
intr-stubs.S
intr-stubs.S
用于低级中断处理的汇编代码。更多信息请参见 A.4.1 中断基础架构章节。
Synch.c
synch.h
基本的同步基元：信号符、锁、条件变量和优化障碍。您需要在所有四个项目中使用这些基元进行同步。更多信息请参见 A.3 同步一节。
io.h
用于访问I/O端口的函数。这主要是由device目录下的源码使用的，你不用去碰。
vaddr.h
pte.h
用于处理虚拟地址和页表项的函数和宏。在项目3中，这些将对你更重要。现在，你可以忽略它们。
flags.h
用于定义80x86 "flags "寄存器中一些位的宏。可能没有人感兴趣。更多信息请参见 [ IA32-v1]，3.4.3 节，"EFLAGS 寄存器"。
fixed-point.h
实现定点运算的函数，用于高级调度器的实现。更多信息参见B.6定点实数运算。

#### 2.1.2.1 "devices" code

基本的线程内核也在设备目录下包含这些文件。

timer.c
timer.h
系统定时器，默认情况下，每秒滴答100次。你将在本项目中修改这段代码。
vga.c
vga.h
VGA显示驱动。负责将文字写入屏幕。printf()会帮你调用VGA显示驱动，所以没有什么理由自己调用这段代码。
serial.c
serial.h
串行端口驱动。同样，printf()会帮你调用这段代码，所以你不需要自己去调用。它通过将串行输入传递给输入层来处理它（见下文）。
块.c
块.h
块设备的抽象层，也就是随机访问的、类似磁盘的设备，它们被组织成固定大小的块数组。开箱即用，Pintos支持两种类型的块设备。IDE磁盘和分区。不管是哪种类型的块设备，在项目2之前都不会被真正使用。
ide.c
ide.h
支持在最多 4 个 IDE 磁盘上读写扇区。
分区.c
分区.c
理解磁盘上的分区结构，允许将一个磁盘分割成多个区域（分区）独立使用。
kbd.c
kbd.h
键盘驱动程序。处理按键，将它们传递给输入层（见下文）。
输入.c
input.h
输入层。排队处理键盘或串行驱动程序传递过来的输入字符。
intq.c
intq.h
中断队列，用于管理内核线程和中断处理程序都想访问的循环队列。由键盘和串行驱动程序使用。
rtc.c
rtc.h
实时时钟驱动，使内核能够确定当前日期和时间。默认情况下，它只被线程/init.c用来为随机数生成器选择一个初始种子。
扬声器.c
扬声器.h
可以在PC扬声器上产生音调的驱动程序。
pit.c
pit.h
用于配置8254可编程中断定时器的代码。这个代码同时被device/timer.c和device/speaker.c使用，因为每个设备都使用PIT的一个输出通道。

#### 2.1.2.2 "lib" files

最后，lib和lib/kernel包含了有用的库例程，（lib/user将被用户程序使用，从项目2开始，但不是内核的一部分）。(从项目2开始，lib/user将被用户程序使用，但它不是内核的一部分。) 下面是一些细节。

ctype.h
inttypes.h
limit.h
stdarg.h
stdbool.h
stddef.h
stdint.h
stdio.c
stdio.h
stdlib.c
stdlib.h
stdlib.h
stdlib.c
标准C库的一个子集。参见 C.2 C99 节，了解最近引入的一些你可能没有遇到过的 C 库的信息。参见 C.3 Unsafe String Functions 一节，了解哪些是为了安全起见而故意忽略的。
debug.c
debug.h
用于帮助调试的函数和宏。更多信息请参见 E. 调试工具一节。
随机.c
random.h
伪随机数生成器。随机值的实际序列不会因 Pintos 的运行而改变，除非你做了以下三件事之一：在每次运行时在 -rs 内核命令行选项中指定一个新的随机种子值，或者使用 Bochs 以外的模拟器，或者为 pintos 指定 -r 选项。
round.h
用于舍入的宏。
syscall-nr.h
系统调用号码。在项目2之前不使用。
kernel/list.c
kernel/list.h
双重链接列表的实现。在Pintos代码中到处都在使用，你可能会在项目1中自己想使用它的一些地方。
kernel/bitmap.c
kernel/bitmap.h
位图的实现。如果你愿意，你可以在你的代码中使用它，但在项目1中可能不需要它。
kernel/hash.c
内核/hash.h
哈希表的实现。很可能在项目3中派上用场.
kernel/console.c
kernel/console.h
kernel/stdio.h
实现printf()和其他一些函数。

### 2.1.3 同步化

适当的同步是解决这些问题的重要部分。任何同步问题都可以通过关闭中断来轻松解决：当中断关闭时，没有并发，所以不存在竞赛条件的可能性。因此，很想用这种方式解决所有的同步问题，但不要。相反，使用semaphores、锁和条件变量来解决大部分的同步问题。如果您不确定在什么情况下可以使用什么同步基元，请阅读关于同步的游记部分（参见 A.3 同步）或 threads/synch.c 中的注释。

在Pintos项目中，唯一一类通过禁用中断来最佳解决的问题是协调内核线程和中断处理程序之间的共享数据。因为中断处理程序不能睡觉，所以它们不能获取锁。这意味着内核线程和中断处理程序之间共享的数据必须在内核线程内通过关闭中断来保护。

这个项目只需要从中断处理程序中访问一点线程状态。对于闹钟，定时器中断需要唤醒睡眠线程。在高级调度器中，定时器中断需要访问一些全局变量和每个线程变量。当你从内核线程访问这些变量时，你需要禁用中断以防止定时器中断的干扰。

当你关闭中断时，要注意尽可能减少代码量，否则你可能最终会丢失重要的东西，如定时器滴答或输入事件。关闭中断也会增加中断处理的延迟，如果采取得太过分，会使机器感觉迟钝。

synch.c中的同步基元本身是通过禁用中断来实现的。您可能需要增加在这里禁用中断时运行的代码量，但仍应尽量将其保持在最低限度。

如果你想确保某段代码不被中断，禁用中断对于调试是很有用的。你应该在上交项目之前删除调试代码。(不要只把它注释出来，因为那会使代码难以阅读)。

在你提交的项目中不应该有繁忙的等待。调用thread_yield()的紧缩循环是繁忙等待的一种形式。

### 2.1.4 开发建议

在过去，很多小组将任务分成几块，然后每个组员都在自己的作品中工作，直到截止日期前，这时，小组再次召开会议，合并他们的代码并提交。这是一个坏主意。我们不推荐这种方法。这样做的小组经常会发现两个改动相互冲突，需要在最后一刻进行大量的调试。一些这样做的小组交出的代码甚至没有编译或启动，更不用说通过任何测试了。

相反，我们建议使用像 Git 这样的源代码控制系统，尽早、频繁地整合你团队的变更（参见 F.3 节 Git）。这样更不容易产生意外，因为每个人都可以看到其他人的代码，而不是仅仅在代码写完后才看到。这些系统还可以审查修改，当修改带来一个错误时，可以退回到工作版本的代码。

你应该预料到，在从事这个项目和后续项目时，会遇到一些你根本不理解的bug。当你遇到这种情况时，请重新阅读关于调试工具的附录，其中充满了有用的调试技巧，应该可以帮助你恢复速度（参见E. 调试工具一节）。一定要阅读关于回溯的一节(见E.4节回溯)，这将帮助你从每次内核恐慌或断言失败中获得最大的帮助。

## 2.2 所需经费

### 2.2.1 设计文档
在您提交项目之前，您必须将项目1的设计文档模板复制到您的源代码树中，以`pintos/src/threads/DESIGNDOC`为名，并将其填入。我们建议你在开始项目工作之前阅读设计文档模板。参见D.项目文档一节，以获得与一个虚构项目配套的设计文档示例。

### 2.2.2 Alarm Clock
重新实现在devices/timer.c中定义的timer_sleep()。虽然提供了一个可行的实现，但它是 "忙碌的等待"，也就是说，它在一个循环中旋转，检查当前时间并调用thread_yield()，直到足够的时间过去。重新实现它以避免忙等。

`Function：void timer_sleep (int64_t ticks)`

> 暂停调用线程的执行，直到时间至少提前了x个定时器滴答。除非系统处于其他空闲状态，否则线程不需要在正好x个ticks后唤醒。只需在它们等待了适当的时间后，将其放在准备好的队列中即可。
> timer_sleep()对于实时运行的线程非常有用，例如每秒闪烁一次光标。
>
> timer_sleep()的参数以定时器ticks表示，而不是以毫秒或其他单位表示。每秒钟有TIMER_FREQ定时器ticks，其中TIMER_FREQ是devices/timer.h中定义的宏。默认值是100。我们不建议改变这个值，因为任何改变都可能导致许多测试失败。

单独的函数 timer_msleep(), timer_usleep(), 和 timer_nsleep()确实存在，分别用于睡眠特定数量的毫秒、微秒或纳秒，但这些函数会在必要时自动调用 timer_sleep()。你不需要修改它们。

如果你的延迟看起来太短或太长，请重新阅读对 pintos 的 -r 选项的解释（见 1.1.4 节调试与测试）。

闹钟的实现在以后的项目中是不需要的，尽管它可能对项目4有用。

### 2.2.3 Priority Scheduling

在Pintos中实现优先级调度。当一个线程被添加到就绪列表中，而该线程的优先级高于当前运行的线程时，当前线程应立即将处理器让给新线程。同样，当线程在等待锁、信号体或条件变量时，应该先唤醒优先级最高的等待线程。线程可以在任何时候提高或降低自己的优先级，但降低其优先级使其不再具有最高优先级时，必须使其立即让渡CPU。

线程优先级的范围从PRI_MIN (0)到PRI_MAX (63)。较低的数字对应较低的优先级，因此优先级0是最低的优先级，优先级63是最高的优先级。初始的线程优先级会作为参数传递给 thread_create()。如果没有理由选择其他优先级，就使用PRI_DEFAULT（31）。PRI_宏定义在threads/thread.h中，你不应该改变它们的值。

优先级调度的一个问题是 "优先级反转"。分别考虑高、中、低优先级线程H、M、L。如果H需要等待L（例如，等待L持有的锁），而M在就绪列表中，那么H将永远不会得到CPU，因为低优先级线程不会得到任何CPU时间。这个问题的部分修复方法是H在L持有锁的时候将其优先级 "捐献 "给L，然后在L释放（从而H获得）锁后再回收捐献。

实现优先权捐赠。你需要考虑到所有需要优先权捐赠的不同情况。一定要处理多重捐赠，在这种情况下，多个优先权被捐赠给一个线程。你还必须处理嵌套捐赠：如果H正在等待M持有的锁，而M正在等待L持有的锁，那么M和L都应该提升到H的优先级。如果有必要，你可以对嵌套优先捐赠的深度进行合理的限制，比如8级。

你必须对锁实施优先级捐赠。你不需要为其他Pintos同步构造实现优先级捐赠。你确实需要在所有情况下实现优先级调度。

最后，实现以下函数，允许线程检查和修改自己的优先级。这些函数的骨架在 threads/thread.c 中提供。

函数：**void thread_set_priority (int new_priority)**

> 将当前线程的优先级设置为new_priority。如果当前线程不再具有最高优先级，则产生。

函数：**int thread_get_priority (void)**

> 返回当前线程的优先级。在存在优先级捐赠的情况下，返回较高的（捐赠的）优先级。
> 你不需要提供任何接口来允许一个线程直接修改其他线程的优先级。

在以后的任何项目中，都不会用到优先级调度器。

### 2.2.4 Advanced Scheduler
实现一个类似于4.4BSD调度器的多级反馈队列调度器，以减少系统上运行作业的平均响应时间。详细要求请参见B节4.4BSD调度器。

和优先级调度器一样，高级调度器根据优先级来选择运行的线程。然而，高级调度器不进行优先级捐赠。因此, 我们建议你在开始使用高级调度器之前, 先让优先级调度器工作, 可能是为了优先级捐赠.

你必须编写你的代码，让我们在Pintos启动时选择一个调度算法策略。默认情况下，优先级调度器必须是活动的，但我们必须能够使用-mlfqs内核选项选择4.4BSD调度器。传递这个选项会在 parse_options()解析选项时，将 threads/thread.h 中声明的 thread_mlfqs 设置为 true，这在 main() 的早期就会发生。

当启用 4.4BSD 调度器时，线程不再直接控制自己的优先级。thread_create()的优先级参数应该被忽略, 还有对 thread_set_priority()的调用, thread_get_priority()应该返回调度器设置的线程的当前优先级.

在以后的项目中都不会使用高级调度器。

## 2.3 常见问题

**我需要写多少代码？**

下面是我们的参考方案的摘要，由diffstat程序产生。最后一行给出了插入和删除的总行数；改变的行数既是插入也是删除。

参考方案只是一种可能的解决方案。许多其他的解决方案也是可能的，而且其中许多方案与参考方案有很大的不同。一些优秀的解决方案可能不会修改所有被参考方案修改过的文件，一些可能会修改参考方案没有修改过的文件。

 device/timer.c | 42 +++++-
 threads/synch.c | 88 ++++++++++++-。
 threads/thread.c | 196 ++++++++++++++++++++++++++----。
 threads/thread.h |23 +++。
 更改4个文件，插入320个(+)，删除29个(-)

**当我添加一个新的源文件时，如何更新Makefile？**

要添加一个.c文件，编辑顶层的Makefile.build。将新文件添加到变量dir_SRC中，其中dir是你添加文件的目录。对于这个项目，这意味着你应该把它添加到 threads_SRC 或 devices_SRC 中。然后运行make。如果你的新文件没有被编译，运行 make clean 然后再试一次。

当你修改顶层的Makefile.build并重新运行make时，修改后的版本应该会自动复制到线程/build/Makefile中。反之则不然，所以当你下次从线程目录下运行make clean时，任何修改都会丢失。除非你的改动是临时性的，否则你最好编辑Makefile.build。

一个新的.h文件不需要编辑Makefile。

**warning: no previous prototype for `func' 是什么意思？**

这意味着你定义了一个非静态函数，而没有在其前面加上原型。因为非静态函数是要被其他.c文件使用的，为了安全起见，它们应该在定义前的头文件中加入原型。要解决这个问题，请在您包含的头文件中添加一个原型，或者，如果函数实际上没有被其他.c文件使用，则将其静态化。

**定时器中断的间隔时间是多少？**

定时器中断发生的次数为每秒TIMER_FREQ次。你可以通过编辑device/timer.h来调整这个值。默认值是100 Hz。

我们不建议改变这个值，因为任何改变都可能导致许多测试失败。

**一个时间片有多长？**

每个时间片有TIME_SLICE的ticks。这个宏在threads/thread.c中声明，默认为4 ticks。

我们不建议改变这个值，因为任何改变都可能导致许多测试失败。

**如何运行测试？**

参见 1.2.1 测试。

**我应该尝试使用抖动运行测试吗？**

使用Bochs中的抖动功能（参见1.1.4节调试与测试）是发现依赖于时序的bug的好方法。然而，即使你的代码是正确的，以下测试也会在抖动下失败： alarm-priority, alarm-simultaneous, mlfqs-recent-1, mlfqs-fair-2, mlfqs-fair-20, mlfqs-nice-2, mlfqs-nice-10, and priority-fifo。这些测试的行为有时会因时间的不同而不同（例如，如果定时器中断在不方便的时间到达）。

**为什么我在pass()中得到一个测试失败？**

你可能看到的是类似这样的回溯。


0xc0108810: debug_panic (lib/kernel/debug.c:32)
0xc010a99f: pass (test/threads/tests.c:93)
0xc010bdd3: test_mlfqs_load_1 (...threads/mlfqs-load-1.c:33)
0xc010a8cf: run_test (test/threads/tests.c:51)
0xc0100452: run_task (threads/init.c:283)
0xc0100536: run_actions (threads/init.c:333)
0xc01000bb: main (threads/init.c:137)
这只是回溯程序的混乱输出。它实际上并不是说pass()调用了debug_panic()。事实上，fail()调用了debug_panic()（通过PANIC()宏）。GCC知道debug_panic()不会返回，因为它被声明为NO_RETURN(见E.3节函数和参数属性)，所以它没有在fail()中包含任何代码来控制debug_panic()何时返回。这意味着堆栈上的返回地址看起来像是在内存中恰好跟随fail()的函数的开头，在本例中恰好是pass()。

详见E.4节回溯，了解更多信息。

**如何在 schedule() 之后的新线程中重新启用中断？**

进入schedule()的每一条路径都会禁用中断，它们最终会被下一个被调度的线程重新启用。它们最终会被下一个要调度的线程重新启用。考虑一下各种可能性：新线程在switch_thread()中运行(但见下文)，它被schedule()调用，schedule()被几个可能的函数之一调用。

thread_exit()，但我们永远不会切换回这样的线程，所以它是无趣的。
thread_yield()，从schedule()返回后立即恢复中断级别。
thread_block()，它从多个地方被调用。
sema_down(), 在返回前恢复中断级别。
idle()，用显式汇编STI指令启用中断。
devices/intq.c中的wait()，其调用者负责重新启用中断。
当一个新创建的线程第一次运行时，有一种特殊情况。这样的线程调用intr_enable()作为kernel_thread()中的第一个动作，它在调用栈的底部，除了第一个线程外，其他线程都是如此。

### 2.3.1 闹钟常见问题
**我需要考虑定时器值溢出的问题吗？**

不用担心定时器值溢出的可能性。定时器值以有符号的64位数表示，以每秒100次计算，应该可以使用近2,924,712,087年。届时，我们预计Pintos将被淘汰出计算机科学课程。

### 2.3.2 优先级调度常见问题
**优先级调度不会导致饥饿吗？**

是的，严格的优先级调度会导致饥饿，因为如果有更高优先级的线程可以运行，线程就不会运行。高级调度器引入了一种动态改变线程优先级的机制。

严格的优先级调度在实时系统中是很有价值的，因为它为程序员提供了更多的控制权，可以控制哪些作业获得处理时间。高优先级通常保留给时间紧迫的任务。这并不 "公平"，但它解决了其他不适用于通用操作系统的问题。

**锁被释放后，应该运行什么线程？**

当一个锁被释放时，等待该锁的最高优先级线程应该被解锁，并放在准备好的线程列表中。然后，调度器应该运行就绪列表中优先级最高的线程。

**如果最高优先级的线程屈服了，它是否继续运行？**

是的，如果有一个最高优先级的线程，它将继续运行，直到它阻塞或完成，即使它调用了 thread_yield()。如果多个线程具有相同的最高优先级，那么 thread_yield()应该按照 "轮回 "顺序在它们之间切换。

**捐赠线程的优先级会发生什么变化？**

优先级捐赠只改变受捐线程的优先级。捐赠线程的优先级是不变的。优先级捐赠不是相加的：如果线程A（优先级为5）捐赠给线程B（优先级为3），那么B的新优先级是5，而不是8。

**当一个线程在就绪队列中时，它的优先级可以改变吗？**

可以。考虑一个准备好的、低优先级的线程L，它持有一个锁。高优先级线程H试图获取锁并进行阻塞，从而将其优先级捐赠给就绪线程L。

**当一个线程被阻塞时，它的优先级可以改变吗？**

可以。当一个已经获得锁L的线程由于任何原因被阻塞时，如果一个高优先级的线程试图获得L，它的优先级可以通过优先级捐赠来增加，这种情况可以通过优先级捐赠-sema测试来检查。

**添加到就绪列表的线程能否抢先处理器？**

是的，如果一个添加到就绪列表的线程比正在运行的线程有更高的优先级，正确的行为是立即让渡处理器。等待下一个定时器中断是不可接受的。最高优先级的线程一旦可以运行，就应该立即运行，抢占当前正在运行的任何线程。

**thread_set_priority()如何影响接受捐赠的线程？**

它设置线程的基本优先级。线程的有效优先级会变成新设置的优先级和捐赠的最高优先级中的较高者。当捐赠被释放时，线程的优先级会变成通过函数调用设置的优先级。这种行为由优先级-捐赠-降低测试来检查。

**输出中的测试名称双倍会使其失败。**

假设你看到的输出中，有些测试名称是双倍的，像这样。

>(alarm-priority) begin 
>
>(alarm-priority) (alarm-priority) Thread priority 30 woke up. 
>
>Thread priority 29 woke up. 
>
>(alarm-priority) Thread priority 28 woke up.

现在发生的情况是，两个线程的输出被交错在一起。也就是说，一个线程正在打印"(alarm-priority) Thread priority 29 woke up.\n"，而另一个线程正在打印"(alarm-priority) Thread priority 30 woke up.\n"，但第一个线程在其输出中间被第二个线程抢先。

这个问题说明你的优先级调度器有bug。毕竟，一个优先级为29的线程不应该在优先级为30的线程有工作要做的时候运行。

通常，Pintos内核中printf()函数的实现试图通过在printf调用期间获取一个控制台锁并在之后释放它来防止这种交错输出。然而，测试名称的输出，例如（alarm-priority），以及后面的消息是使用两次调用printf来输出的，导致控制台锁被获取和释放两次。

### 2.3.3 高级调度器常见问题解答
**优先捐赠如何与高级调度器互动？**

没有必要。我们不会同时测试优先捐赠和高级调度器。

**我可以使用一个队列而不是64个队列吗？**

是的，一般来说，你的实现可能与描述不同，只要它的行为是相同的。

**有些调度器测试失败了，我不明白为什么。请帮助我**

如果你的实现在一些高级调度器测试中神秘地失败了，请尝试以下方法。

阅读那些失败的测试的源文件 以确保你明白发生了什么事 每一个测试的顶部都有一个注释，解释其目的和预期结果。
仔细检查你的定点算术例程，以及你在调度例程中对它们的使用。
考虑你的实现在定时器中断中做了多少工作。如果定时器中断处理程序需要的时间太长，那么它将从定时器中断所抢占的线程中拿走大部分的定时器tick。当它将控制权返回给该线程时，因此在下一个定时器中断到来之前，它不会得到做太多工作。因此，该线程将被指责为比它实际有机会使用的CPU时间更多。这就提高了被中断线程的最近CPU数，从而降低了它的优先级。它可以导致调度决策的改变。它还会提高负载平均值。