既然您已经使用过Pintos，并且已经熟悉了其基础结构和线程包，那么该开始着手研究允许运行用户程序的系统部分了。 基本代码已经支持加载和运行用户程序，但是无法进行I / O或交互。 在此项目中，将使程序能够通过系统调用与OS交互。

您将不在userprog目录中进行此分配，但是您还将与Pintos的几乎所有其他部分进行交互。 我们将在下面描述相关部分。

您可以在提交的项目1的基础上构建项目2，也可以重新开始。 此分配不需要项目1的代码。 “alarm clock”功能在项目3和4中可能很有用，但并非严格要求。

您可能会发现返回并重新阅读如何运行测试很有用（请参阅1.2.1测试）。



#### 3.1 背景

到目前为止，您在Pintos下运行的所有代码都已成为操作系统内核的一部分。例如，这意味着上一次作业中的所有测试代码都作为内核的一部分运行，并且可以完全访问系统的特权部分。一旦我们开始在操作系统之上运行用户程序，那就不再如此，这个项目将处理这些结构。

我们允许一次运行多个进程。每个进程都有一个线程（不支持多线程进程）。用户程序是在他们拥有整个计算机系统的错觉下编写的。这意味着当您一次加载并运行多个进程时，必须正确管理内存，调度和其他状态以维持这种错觉。

在上一个项目中，我们将测试代码直接编译到了内核中，因此我们必须在内核中需要某些特定的功能接口。从现在开始，我们将通过运行用户程序来测试您的操作系统。这给您更大的自由。您必须确保用户程序界面符合此处描述的规范，但是在有此约束的情况下，您可以随意重组或重写内核代码。



##### 3.1.1源文件

概述将要进行的编程的最简单方法是简单地遍历要使用的每个部分。在userprog中，您会找到少量文件，但是部份您主要需要编写的地方：



process.c
process.h
加载ELF二进制文件并启动进程。
pagedir.c
pagedir.h
80x86硬件页表的简单管理器。尽管您可能不想为本项目修改此代码，但是您可能希望调用其某些功能。有关更多信息，请参见4.1.2.3页表部分。
syscall.c
syscall.h
每当用户进程想要访问某些内核功能时，它就会调用系统调用。这是一个骨架系统调用处理程序。当前，它仅打印一条消息并终止用户进程。在该项目的第2部分中，您将添加代码来执行系统调用所需的其他所有操作。
exception.c
exception.h
当用户进程执行特权或禁止的操作时，它会作为“异常”或“故障”进入内核。（3）这些文件处理异常。当前，所有异常仅会打印一条消息并终止该过程。项目2的某些（但不是全部）解决方案需要修改此文件中的page_fault（）。
gdt.c
gdt.h
80x86是分段架构。全局描述符表（GDT）是描述正在使用的段的表。这些文件设置了GDT。您无需为任何项目修改这些文件。如果您对GDT的工作方式感兴趣，可以阅读代码。
tss.c
tss.h
任务状态段（TSS）用于80x86体系结构任务切换。当用户进程进入中断处理程序时，Pintos仅将TSS用于交换堆栈，Linux也是如此。您无需为任何项目修改这些文件。如果您对TSS的工作方式感兴趣，可以阅读代码。



##### 3.1.2使用文件系统

您将需要接口到该项目的文件系统代码，因为用户程序是从文件系统加载的，并且您必须执行许多系统调用来处理文件系统。但是，该项目的重点不是文件系统，因此我们在filesys目录中提供了一个简单但完整的文件系统。您将需要查看filesys.h和file.h接口，以了解如何使用文件系统，尤其是其许多限制。

无需修改该项目的文件系统代码，因此我们建议您不要这样做。在文件系统上工作可能会使您分心于该项目的重点。

现在，当您改进文件系统实现时，正确使用文件系统例程将使项目4的工作变得更加轻松。在此之前，您将必须忍受以下限制：

没有内部同步。并发访问会互相干扰。您应该使用同步来确保一次只有一个进程正在执行文件系统代码。
文件大小在创建时是固定的。根目录表示为一个文件，因此可以创建的文件数也受到限制。
文件数据是按单个扩展区分配的，也就是说，单个文件中的数据必须占据磁盘上连续的扇区范围。因此，随着时间的推移使用文件系统，外部碎片会成为一个严重的问题。
没有子目录。
文件名限制为14个字符。
系统崩溃的中间操作可能会以无法自动修复的方式损坏磁盘。无论如何，没有文件系统修复工具。
其中包括一项重要功能：

实现了filesys_remove（）的类Unix语义。也就是说，如果在删除文件时打开了该文件，则不会释放其块，并且打开该文件的任何线程仍可以访问该文件，直到最后一个文件关闭为止。有关更多信息，请参见删除打开的文件。
您需要能够创建具有文件系统分区的模拟磁盘。 pintos-mkdisk程序提供了此功能。在userprog / build目录中，执行pintos-mkdisk filesys.dsk --filesys-size = 2。此命令将创建一个名为filesys.dsk的模拟磁盘，其中包含2 MB的Pintos文件系统分区。然后通过在内核的命令行上传递-f -q格式化文件系统分区：pintos -f -q。 -f选项使文件系统格式化，而-q选项使Pintos在格式化完成后立即退出。

您需要一种将文件复制到模拟文件系统中以及从模拟文件系统复制文件的方法。使用pintos -p（“put”）和-g（“get”）选项可以执行此操作。要将文件复制到Pintos文件系统中，请使用命令pintos -p file --q。 （之所以需要--，是因为-p用于pintos脚本，而不是模拟内核。）要将其复制到名称为newname的Pintos文件系统中，请添加-a newname：pintos -p file -a newname-- q。用于从VM复制文件的命令是相似的，但是用-g代替-p。

顺便说一下，这些命令通过传递特殊的命令来工作，这些命令在内核的命令行中提取并追加，并在一个特殊的模拟“ scratch”分区之间进行复制。如果您很好奇，可以查看pintos脚本以及filesys / fsutil.c来了解实现细节。

以下是有关如何创建具有文件系统分区的磁盘，格式化文件系统，将echo程序复制到新磁盘中，然后运行echo并传递参数x。 （参数传递在实现之前是行不通的。）假定您已经在示例中构建了示例，并且当前目录为userprog / build：

```
pintos-mkdisk filesys.dsk --filesys-size=2
pintos -f -q
pintos -p ../../examples/echo -a echo -- -q
pintos -q run 'echo x'
```

最后三个步骤实际上可以组合成一个命令：

```
pintos-mkdisk filesys.dsk --filesys-size=2
pintos -p ../../examples/echo -a echo -- -f -q run 'echo x'
```

如果您不希望保留文件系统磁盘以备后用或检查，甚至可以将所有四个步骤合并为一个命令。 --filesys-size = n选项仅在pintos运行期间创建一个大约n兆字节大小的临时文件系统分区。 Pintos自动测试套件广泛使用了以下语法：

```
pintos --filesys-size=2 -p ../../examples/echo -a echo -- -f -q run 'echo x'
```

您可以使用rm文件内核操作从Pintos文件系统中删除文件，例如pintos -q rm文件。另外，ls列出了文件系统中的文件，而cat文件将文件的内容打印到显示屏上。