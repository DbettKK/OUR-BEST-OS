既然您已经使用过Pintos，并且已经熟悉了其基础结构和线程包，那么该开始着手研究允许运行用户程序的系统部分了。 基本代码已经支持加载和运行用户程序，但是无法进行I / O或交互。 在此项目中，将使程序能够通过系统调用与OS交互。

您将不在userprog目录中进行此分配，但是您还将与Pintos的几乎所有其他部分进行交互。 我们将在下面描述相关部分。

您可以在提交的项目1的基础上构建项目2，也可以重新开始。 此分配不需要项目1的代码。 “alarm clock”功能在项目3和4中可能很有用，但并非严格要求。

您可能会发现返回并重新阅读如何运行测试很有用（请参阅1.2.1测试）。



#### 3.1 背景

到目前为止，您在Pintos下运行的所有代码都已成为操作系统内核的一部分。例如，这意味着上一次作业中的所有测试代码都作为内核的一部分运行，并且可以完全访问系统的特权部分。一旦我们开始在操作系统之上运行用户程序，那就不再如此，这个项目将处理这些结构。

我们允许一次运行多个进程。每个进程都有一个线程（不支持多线程进程）。用户程序是在他们拥有整个计算机系统的错觉下编写的。这意味着当您一次加载并运行多个进程时，必须正确管理内存，调度和其他状态以维持这种错觉。

在上一个项目中，我们将测试代码直接编译到了内核中，因此我们必须在内核中需要某些特定的功能接口。从现在开始，我们将通过运行用户程序来测试您的操作系统。这给您更大的自由。您必须确保用户程序界面符合此处描述的规范，但是在有此约束的情况下，您可以随意重组或重写内核代码。



##### 3.1.1源文件

概述将要进行的编程的最简单方法是简单地遍历要使用的每个部分。在userprog中，您会找到少量文件，但是部份您主要需要编写的地方：



process.c

process.h

加载ELF二进制文件并启动进程。

pagedir.c

pagedir.h

80x86硬件页表的简单管理器。尽管您可能不想为本项目修改此代码，但是您可能希望调用其某些功能。有关更多信息，请参见4.1.2.3页表部分。

syscall.c

syscall.h

每当用户进程想要访问某些内核功能时，它就会调用系统调用。这是一个骨架系统调用处理程序。当前，它仅打印一条消息并终止用户进程。在该项目的第2部分中，您将添加代码来执行系统调用所需的其他所有操作。

exception.c

exception.h

当用户进程执行特权或禁止的操作时，它会作为“异常”或“故障”进入内核。（3）这些文件处理异常。当前，所有异常仅会打印一条消息并终止该过程。项目2的某些（但不是全部）解决方案需要修改此文件中的page_fault（）。

gdt.c

gdt.h

80x86是分段架构。全局描述符表（GDT）是描述正在使用的段的表。这些文件设置了GDT。您无需为任何项目修改这些文件。如果您对GDT的工作方式感兴趣，可以阅读代码。

tss.c

tss.h

任务状态段（TSS）用于80x86体系结构任务切换。当用户进程进入中断处理程序时，Pintos仅将TSS用于交换堆栈，Linux也是如此。您无需为任何项目修改这些文件。如果您对TSS的工作方式感兴趣，可以阅读代码。



##### 3.1.2使用文件系统

您将需要接口到该项目的文件系统代码，因为用户程序是从文件系统加载的，并且您必须执行许多系统调用来处理文件系统。但是，该项目的重点不是文件系统，因此我们在filesys目录中提供了一个简单但完整的文件系统。您将需要查看filesys.h和file.h接口，以了解如何使用文件系统，尤其是其许多限制。

无需修改该项目的文件系统代码，因此我们建议您不要这样做。在文件系统上工作可能会使您分心于该项目的重点。

现在，当您改进文件系统实现时，正确使用文件系统例程将使项目4的工作变得更加轻松。在此之前，您将必须忍受以下限制：

没有内部同步。并发访问会互相干扰。您应该使用同步来确保一次只有一个进程正在执行文件系统代码。

文件大小在创建时是固定的。根目录表示为一个文件，因此可以创建的文件数也受到限制。

文件数据是按单个扩展区分配的，也就是说，单个文件中的数据必须占据磁盘上连续的扇区范围。因此，随着时间的推移使用文件系统，外部碎片会成为一个严重的问题。

没有子目录
。
文件名限制为14个字符。

系统崩溃的中间操作可能会以无法自动修复的方式损坏磁盘。无论如何，没有文件系统修复工具。

其中包括一项重要功能：

实现了filesys_remove（）的类Unix语义。也就是说，如果在删除文件时打开了该文件，则不会释放其块，并且打开该文件的任何线程仍可以访问该文件，直到最后一个文件关闭为止。有关更多信息，请参见删除打开的文件。

您需要能够创建具有文件系统分区的模拟磁盘。 pintos-mkdisk程序提供了此功能。在userprog / build目录中，执行pintos-mkdisk filesys.dsk --filesys-size = 2。此命令将创建一个名为filesys.dsk的模拟磁盘，其中包含2 MB的Pintos文件系统分区。然后通过在内核的命令行上传递-f -q格式化文件系统分区：pintos -f -q。 -f选项使文件系统格式化，而-q选项使Pintos在格式化完成后立即退出。

您需要一种将文件复制到模拟文件系统中以及从模拟文件系统复制文件的方法。使用pintos -p（“put”）和-g（“get”）选项可以执行此操作。要将文件复制到Pintos文件系统中，请使用命令pintos -p file --q。 （之所以需要--，是因为-p用于pintos脚本，而不是模拟内核。）要将其复制到名称为newname的Pintos文件系统中，请添加-a newname：pintos -p file -a newname-- q。用于从VM复制文件的命令是相似的，但是用-g代替-p。

顺便说一下，这些命令通过传递特殊的命令来工作，这些命令在内核的命令行中提取并追加，并在一个特殊的模拟“ scratch”分区之间进行复制。如果您很好奇，可以查看pintos脚本以及filesys / fsutil.c来了解实现细节。

以下是有关如何创建具有文件系统分区的磁盘，格式化文件系统，将echo程序复制到新磁盘中，然后运行echo并传递参数x。 （参数传递在实现之前是行不通的。）假定您已经在示例中构建了示例，并且当前目录为userprog / build：

```
pintos-mkdisk filesys.dsk --filesys-size=2
pintos -f -q
pintos -p ../../examples/echo -a echo -- -q
pintos -q run 'echo x'
```

最后三个步骤实际上可以组合成一个命令：

```
pintos-mkdisk filesys.dsk --filesys-size=2
pintos -p ../../examples/echo -a echo -- -f -q run 'echo x'
```

如果您不希望保留文件系统磁盘以备后用或检查，甚至可以将所有四个步骤合并为一个命令。 --filesys-size = n选项仅在pintos运行期间创建一个大约n兆字节大小的临时文件系统分区。 Pintos自动测试套件广泛使用了以下语法：

```
pintos --filesys-size=2 -p ../../examples/echo -a echo -- -f -q run 'echo x'
```

您可以使用rm文件内核操作从Pintos文件系统中删除文件，例如pintos -q rm文件。另外，ls列出了文件系统中的文件，而cat文件将文件的内容打印到显示屏上。

##### 3.1.3 用户程序的工作方式

Pintos可以运行普通的C程序，只要它们适合内存并且仅使用您实现的系统调用即可。值得注意的是，无法实现malloc（），因为该项目所需的所有系统调用均不允许进行内存分配。 Pintos也不能运行使用浮点运算的程序，因为在切换线程时内核不会保存和恢复处理器的浮点单元。

src / examples目录包含一些示例用户程序。此目录中的Makefile会编译提供的示例，您也可以对其进行编辑以编译您自己的程序。一些示例程序仅在实施项目3或4后才起作用。

Pintos可以使用userprog / process.c中为您提供的加载器加载ELF可执行文件。 ELF是Linux，Solaris和许多其他操作系统使用的文件格式，用于目标文件，共享库和可执行文件。实际上，您可以使用任何输出80x86 ELF可执行文件的编译器和链接器为Pintos生成程序。 （我们提供了可以正常运行的编译器和链接器。）

您应该立即意识到，在将测试程序复制到模拟文件系统之前，Pintos将无法做有用的工作。在将各种程序复制到文件系统之前，您将无法做一些有趣的事情。您可能想要创建一个干净的参考文件系统磁盘，并在将filesys.dsk破坏到超出有用状态时将其复制过来，这可能在debug时偶尔发生。



##### 3.1.4 虚拟内存布局

Pintos中的虚拟内存分为两个区域：用户虚拟内存和内核虚拟内存。用户虚拟内存的范围从虚拟地址0到PHYS_BASE，在thread/vaddr.h中定义，默认值为0xc0000000（3 GB）。内核虚拟内存占据了其余虚拟地址空间，从PHYS_BASE到最大4 GB。

用户虚拟内存是按进程的。当内核从一个进程切换到另一个进程时，它也会通过更改处理器的页面目录基址寄存器（请参阅userprog / pagedir.c中的pagedir_activate（））来切换用户虚拟地址空间。 struct线程包含一个指向进程的页表的指针。

内核虚拟内存是全局的。无论运行什么用户进程或内核线程，它始终以相同的方式映射。在Pintos中，从PHYS_BASE开始，内核虚拟内存被一对一映射到物理内存。也就是说，虚拟地址PHYS_BASE访问物理地址0，虚拟地址PHYS_BASE + 0x1234访问物理地址0x1234，依此类推，直到机器的物理内存大小为止。

用户程序只能访问其自己的用户虚拟内存。尝试访问内核虚拟内存会导致页面错误，由userprog / exception.c中的page_fault（）处理，该过程将终止。内核线程可以访问内核虚拟内存，也可以访问正在运行的进程的用户虚拟内存（如果用户进程正在运行）。但是，即使在内核中，尝试以未映射的用户虚拟地址访问内存也会导致页面错误。



##### 3.1.4.1 典型的内存布局

从概念上讲，每个进程都可以随意选择自己的用户虚拟内存。实际上，用户虚拟内存的布局如下：

PHYS_BASE +----------------------------------+

             |            user stack            |
             
             |                 |                |
             
             |                 |                |
             
             |                 V                |
             
             |          grows downward          |
             
             |                                  |
             
             |                                  |
             
             |                                  |
             
             |                                  |
             
             |           grows upward           |
             
             |                 ^                |
             
             |                 |                |
             
             |                 |                |
             
             +----------------------------------+
             
             | uninitialized data segment (BSS) |
             
             +----------------------------------+
             
             |     initialized data segment     |
             
             +----------------------------------+
             
             |           code segment           |
             
  0x08048000 +----------------------------------+
  
             |                                  |
             
             |                                  |
             
             |                                  |
             
             |                                  |
             
             |                                  |
             
           0 +----------------------------------+


在此项目中，用户堆栈的大小是固定的，但在项目3中，将允许其增长。传统上，未初始化的数据段的大小可以通过系统调用来调整，但是您不必实现这一点。

Pintos中的代码段始于用户虚拟地址0x08084000，距离地址空间底部大约128 MB。此值在[SysV-i386]中指定，没有深远的意义。

链接器按照“链接器脚本”的指示设置用户程序在内存中的布局，该脚本告诉它各个程序段的名称和位置。您可以通过阅读链接器手册中的“脚本”一章来了解有关链接器脚本的更多信息，可通过info ld进行访问。

要查看特定可执行文件的布局，请使用-p选项运行objdump（80x86）或i386-elf-objdump（SPARC）。



##### 3.1.5 访问用户内存

作为系统调用的一部分，内核必须经常通过用户程序提供的指针访问内存。内核必须非常小心，因为用户可以传递一个空指针，一个指向未映射虚拟内存的指针或一个指向内核虚拟地址空间（在PHYS_BASE之上）的指针。通过终止有问题的进程并释放其资源，必须拒绝所有这些类型的无效指针，而不会损害内核或其他正在运行的进程。

至少有两种合理的方法可以正确地执行此操作。第一种方法是验证用户提供的指针的有效性，然后取消引用它。如果选择此路由，则需要查看userprog / pagedir.c和threads / vaddr.h中的函数。这是处理用户内存访问的最简单方法。

第二种方法是仅检查指向低于PHYS_BASE的用户指针，然后对其取消引用。无效的用户指针将导致“页面错误”，您可以通过修改userprog / exception.c中的page_fault（）代码来处理。该技术通常更快，因为它利用了处理器的MMU，因此倾向于在实际内核（包括Linux）中使用。

无论哪种情况，都需要确保不要“泄漏”资源。例如，假设您的系统调用已使用malloc（）获得了锁定或分配的内存。如果之后遇到无效的用户指针，则仍必须确保释放锁定或释放内存页面。如果您选择在取消引用用户指针之前先进行验证，则这应该很简单。如果无效指针导致页面错误，则更难处理，因为无法从内存访问中返回错误代码。因此，对于那些想尝试后一种技术的人，我们将提供一些有用的代码：

```c
/* Reads a byte at user virtual address UADDR.
   UADDR must be below PHYS_BASE.
   Returns the byte value if successful, -1 if a segfault
   occurred. */
static int
get_user (const uint8_t *uaddr)
{
  int result;
  asm ("movl $1f, %0; movzbl %1, %0; 1:"
       : "=&a" (result) : "m" (*uaddr));
  return result;
}
 
/* Writes BYTE to user address UDST.
   UDST must be below PHYS_BASE.
   Returns true if successful, false if a segfault occurred. */
static bool
put_user (uint8_t *udst, uint8_t byte)
{
  int error_code;
  asm ("movl $1f, %0; movb %b2, %1; 1:"
       : "=&a" (error_code), "=m" (*udst) : "q" (byte));
  return error_code != -1;
}
```

这些功能中的每一个均假设用户地址已被验证为低于PHYS_BASE。 他们还假定您已经修改了page_fault（），以便内核中的页面错误仅将eax设置为0xffffffff并将其以前的值复制到eip中。



#### 3.2 建议的执行顺序

我们建议首先实现以下步骤，这些步骤可以并行进行：

参数传递（请参阅第3.3.3节“参数传递”）。每个用户程序都会立即页面错误，直到实现参数传递为止。

现在，您可能只希望更改

```
* esp = PHYS_BASE;
```

至

```
* esp = PHYS_BASE-12;
```

在setup_stack（）中。这将适用于任何不检查其参数的测试程序，尽管其名称将显示为（null）。

在实现参数传递之前，应仅运行程序而不传递命令行参数。尝试将参数传递给程序会将这些参数包含在程序名称中，因此可能会失败。


用户内存访问（请参阅第3.1.5节“访问用户内存”）。所有系统调用都需要读取用户内存。很少有系统调用需要写入用户内存。

系统调用基础结构（请参阅第3.3.4节“系统调用”）。实现足够的代码以从用户堆栈中读取系统调用号码，并根据该号码将其分配给处理程序。

退出系统调用。每个以正常方式完成的用户程序都会退出。即使是从main（）调用返回的程序也将间接退出（请参见lib / user / entry.c中的_start（））
。
write系统调用用于写入系统控制台fd 1。我们所有的测试程序都将写入控制台（以这种方式实现用户进程版本的printf（）），因此它们都会出现故障，直到可以进行写入为止。

现在，将process_wait（）更改为无限循环（永远等待的循环）。提供的实现会立即返回，因此Pintos将在实际运行任何进程之前关闭电源。您最终将需要提供正确的实现。

实施上述步骤后，用户进程应工作最少。至少，他们可以写入控制台并正确退出。然后，您可以优化实现，以使一些测试开始通过。
