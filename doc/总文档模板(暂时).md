# 小组相关

|  姓名  |   学号   | 贡献百分比 |
| :----: | :------: | :--------: |
| 张涵珂 | 18373734 |    25%     |
|  杨壮  | 17376193 |    25%     |
|  裴昱  | 17375244 |    25%     |
| 杨瑞羿 | 17241055 |    25%     |

#### Github截图



# 通过用例情况

![通过用例情况](../pic/通过用例情况.png)

# 需求分析

## ALARM CLOCK

> 

## PRIORITY SCHEDULING

> 

## ADVANCED SCHEDULER

> 

# 功能设计

## ALARM CLOCK

> 

## PRIORITY SCHEDULING

> 

## ADVANCED SCHEDULER

> 

# 相关问题的回答

## ALARM CLOCK

### DATA STRUCTURES

A1: Copy here the declaration of each new or changed 'struct' or \`struct' member, global or static variable, \`typedef', or enumeration.  Identify the purpose of each in 25 words or less.

> ```c
> // threads/thread.h
> struct thread {
>     // ...
> 	int waiting_time;                   
>     // ...
> }
> ```
>
> 该新增的字段，用于标明每个线程在调用timer_sleep()函数后应该等待的时间。
>

### ALGORITHMS

A2: Briefly describe what happens in a call to timer_sleep(), including the effects of the timer interrupt handler.

>```c
>// devices/timer.c
>void
>timer_sleep(int64_t ticks){
>    int64_t start = timer_ticks (); // 获取当前时间
>    ASSERT (intr_get_level () == INTR_ON);  // 保证中断开启
>    while (timer_elapsed (start) < ticks)   // 循环
>        thread_yield ();  // 将当前线程放入就绪队列
>}
>```
>
>首先通过timer_ticks()函数获得当前系统时间赋给start变量，然后通过断言保证中断的打开，

A3: What steps are taken to minimize the amount of time spent in the timer interrupt handler?

> 

### SYNCHRONIZATION

A4: How are race conditions avoided when multiple threads call timer_sleep() simultaneously?

> 

A5: How are race conditions avoided when a timer interrupt occurs during a call to timer_sleep()?

> 

### RATIONALE

A6: Why did you choose this design?  In what ways is it superior to another design you considered?

> 

## PRIORITY SCHEDULING

### DATA STRUCTURES

B1: Copy here the declaration of each new or changed\`struct\' or\`struct\' member, global or static variable, \`typedef', or enumeration.  Identify the purpose of each in 25 words or less.

> 

B2: Explain the data structure used to track priority donation.
Use ASCII art to diagram a nested donation.  (Alternately, submit a.png file.)

> 

### ALGORITHMS

B3: How do you ensure that the highest priority thread waiting for a lock, semaphore, or condition variable wakes up first?

> 

B4: Describe the sequence of events when a call to lock_acquire() causes a priority donation.  How is nested donation handled?

> 

B5: Describe the sequence of events when lock_release() is called on a lock that a higher-priority thread is waiting for.

> 

### SYNCHRONIZATION

B6: Describe a potential race in thread_set_priority() and explain how your implementation avoids it.  Can you use a lock to avoid this race?

> 

### RATIONALE

B7: Why did you choose this design?  In what ways is it superior to another design you considered?

> 

## ADVANCED SCHEDULER

### DATA STRUCTURES

C1: Copy here the declaration of each new or changed `struct' or
`struct' member, global or static variable, `typedef', or enumeration.  Identify the purpose of each in 25 words or less.
在thread.h中加入：

typedef int fixed_point 用于表示load_avg的单位

struct thread中加入：

int recent_cpu:最近使用的cpu时间

int nice：nice级别

加入全局变量：

fixed_point load_avg:运行线程数量的平均值


> 

### ALGORITHMS

C2: Suppose threads A, B, and C have nice values 0, 1, and 2.  Each has a recent_cpu value of 0.  Fill in the table below showing the scheduling decision and the priority and recent_cpu values for each thread after each given number of timer ticks.



| timer | recent_cpu |      |      | priority |      |      | thread |
| ----- | ---------- | ---- | ---- | -------- | ---- | ---- | ------ |
| ticks | A          | B    | C    | A        | B    | C    | to run |
| 0     | 0          | 1    | 2    | 63       | 61   | 59   | A      |
| 4     | 4          | 1    | 2    | 62       | 61   | 59   | A      |
| 8     | 7          | 2    | 4    | 61       | 61   | 58   | B      |
| 12    | 6          | 6    | 6    | 61       | 59   | 58   | A      |
| 16    | 9          | 6    | 7    | 60       | 59   | 57   | A      |
| 20    | 12         | 6    | 8    | 60       | 59   | 57   | A      |
| 24    | 15         | 6    | 9    | 59       | 59   | 57   | B      |
| 28    | 14         | 10   | 10   | 59       | 58   | 57   | A      |
| 32    | 16         | 10   | 11   | 58       | 58   | 56   | B      |
| 36    | 15         | 14   | 12   | 59       | 57   | 56   | A      |



C3: Did any ambiguities in the scheduler specification make values in the table uncertain?  If so, what rule did you use to resolve them?  Does this match the behavior of your scheduler?
recent_cpu在此处可能计算的较为模糊，因为当我们计算recent_cpu时，我们没有考虑CPU在每4个clock ticks时用于计算的时间由于当CPU需要计算recent_cpu,load_avg时，当前进行的线程需要被让渡出
来停止运行，所以本质上每过4个clock ticks，用于计算recent_cpu的clock ticks数会比4个要小一些，但是由于我们无法找出计算花费的具体时间，我们事实上还是按照直接在recent_cpu上加上4ticks来
计算。

在源程序中，我们还是只计算系统启动以来的ticks数，每4个ticks进行上述计算，所以可以理解为本质上recent_cpu稍微等比例减小了，但是不影响最后的计算结果。

> 

C4: How is the way you divided the cost of scheduling between code inside and outside interrupt context likely to affect performance?
如果cpu将大量时间用于计算recent_cpu,load_avg以及priority，线程可能会被中断，停止运行较长时间，由于得不到足够的运行时间，一个线程运行的时间会比原来变长，占用了更多的cpu时间，从而提升
了它的load_avg,recent_cpu（至少按照计算方法是这样的结果），从而使其优先级降低，进而干扰了整个系统的安排。所以如果用于计算导致的中断时间增加，整个系统的性能就会降低

> 

### RATIONALE

C5: Briefly critique your design, pointing out advantages and disadvantages in your design choices.  If you were to have extra time to work on this part of the project, how might you choose to refine or improve your design?
由于我们的代码没有应用64个队列，而是只用一个队列，所以本质上，我们需要O(n)的时间来将一个线程插入等待队列，在每4个clock ticks计算完优先级之后，又需要O(nlogn)的时间进行排序，当n越大，每过4个clock ticks后用于计算所占用的时间就越大，线程实际上的运行时间就越长，如果用来64个队列，我们直接用数组存一下队列编号，按照优先级的值（0-63）安排就行，只用O(1)的时间复杂度，而重新排序也只用O(n)的时间。

如果有时间的话，使用64个队列在性能上肯定会更优秀。



我们使用了定点数(fixed_point number)的计算方式，将小数点位数固定来代替pintos中不能实现的浮点数运算我们新建了fix.h和fix.c用于储存一系列计算函数，由于每一个计算函数都较为简单，而且每个参数在计算中都只出现一次，我们没有直接将其写在thread.c中。同时对于整体性能而言更加优化，使得代码更加直观。

> 

C6: The assignment explains arithmetic for fixed-point math in detail, but it leaves it open to you to implement it.  Why did you decide to implement it the way you did? If you created an abstraction layer for fixed-point math, that is, an abstract data type and/or a set of functions or macros to manipulate fixed-point numbers, why did you do so?  If not, why not?
首先由于BSD中算法的要求，recent_cpu和load_avg在计算是都是由实数四舍五入至整数，但是pintos无法支持浮点数的使用，所以我们使用了定点数(fixed_point number)的计算方式，即小数点位置固定，以此来变相实现实数运算。

我们的代码直接新建了fix.h和fix.c，创建了一种抽象层，即fixed_point的数据定义以及一系列计算函数，我们没有直接将其写在thread.c中，因为每一个计算函数都较为简单，而且每个参数在计算中都只出现一次，同时对于整体性能而言更加优化，使得代码更加直观。



> 

## SURVEY QUESTIONS


Answering these questions is optional, but it will help us improve the course in future quarters.  Feel free to tell us anything you want--these questions are just to spur your thoughts.  You may also choose to respond anonymously in the course evaluations at the end of the quarter.

In your opinion, was this assignment, or any one of the three problems in it, too easy or too hard?  Did it take too long or too little time?

> 

Did you find that working on a particular part of the assignment gave you greater insight into some aspect of OS design?

> 

Is there some particular fact or hint we should give students in future quarters to help them solve the problems?  Conversely, did you find any of our guidance to be misleading?

> 

Do you have any suggestions for the TAs to more effectively assist students, either for future quarters or the remaining projects?

> 

Any other comments?

> 
